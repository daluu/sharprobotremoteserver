#summary Installation, usage, and details for remote server

<wiki:toc max_depth="3" />

=Installation=

==Prerequisites==

  * .NET Framework (version 2.0 and above, but not tested & compiled against all versions. May work with Mono and .NET 1.x as well, but untested.)
  * [http://www.xml-rpc.net XML-RPC.NET] library (compiled DLL binary)
  * Example .NET remote library, bundled with the generic server, or your own .NET remote (class) library, for use with [http://www.robotframework.org Robot Framework].
  * If using with [http://www.robotframework.org Robot Framework] locally, running server on localhost, then need to install [http://www.robotframework.org Robot Framework].
  * [http://www.sharpdevelop.net SharpDevelop], msbuild, or a version of [http://www.microsoft.com/visualstudio/en-us/ Visual Studio] may be required to compile [http://www.xml-rpc.net XML-RPC.NET] library.

==Installation procedure==

As the remote server acts as a remote library for [http://www.robotframework.org Robot Framework], no installation is needed. But the prerequisites have to be met first.

  # Download and compile [http://www.xml-rpc.net XML-RPC.NET] library, if needed.
  # Download the [http://sharprobotremoteserver.googlecode.com/files/sharprobotremoteserver-1.1.zip generic remote server zip file package].
  # Extract to desired location.
  # Copy over [http://www.xml-rpc.net XML-RPC.NET] library DLL to extracted location, if needed.

You may add additional .NET class library DLLs in extracted location to start the remote server with those libraries instead of the provided example library.

=Usage instructions=

Run *robotremoteserver* passing it path to .NET class library DLL that contains the implementation of keywords (e.g. actual remote library), and name of class to use in the form of *!NamespaceName.!ClassName* without quotes. You can also run server without arguments to get this usage info.

Server also takes optional parameters for keyword documentation, IP address, port, and whether to allow remotely stopping server or they will default to the [http://www.robotframework.org Robot Framework] defaults of localhost/127.0.0.1, 8270, and to allow stopping server, respectively. For keyword documentation, you have to supply an XML documentation file for the .NET class assembly that can be generated during code compilation. If not provided, documentation will simply be blank when called by Robot Framework.

See [RemoteServerDetails#Testing_the_example_remote_library] for an example of usage.

=Testing the example remote library=

Run robotremoteserver with the examplelibrary like follows:

  `robotremoteserver.exe --library examplelibrary.dll --class RobotFramework.ExampleRemoteLibrary --doc examplelibrary_doc.xml`

Then run the [http://robotframework.googlecode.com/svn/trunk/tools/remoteserver/example/remote_tests.html example tests] for remote libraries/servers available from [http://www.robotframework.org Robot Framework] project.

To test stop remote server functionality, you may wish to add a test case, test step, or test case/suite teardown like this:

|| Test Case || Action || Argument ||
|| Stop Server Test || Run Keyword || Stop Remote Server ||

=.NET remote library interface with the generic remote server=

The generic remote server uses .NET reflection to access the actual remote library during runtime using late-binding technique. Alternatively, you may wish to integrate the library code into the remote server and make it non-generic rather than use dynamic loading/late-binding.

The remote server includes keyword *stop_remote_server* so you don't have to implement that in the remote library.

Remote library methods should conform to [http://www.robotframework.org Robot Framework] keyword API specification, meaning: methods should be named as *method_name()* rather than !MethodName() or methodName(); the underscore represents a space; the method is made available as a keyword in [http://www.robotframework.org Robot Framework] named *Method Name*. Alternatively, they might not have to follow this convention, but you would have to modify the remote server to be able to translate the Robot Framework keyword naming convention to the actual .NET method naming convention when XML-RPC calls are made to *run_keyword*.

Additionally, the library's use of data types in keyword arguments or return values should conform to the [http://www.xmlrpc.com/spec XML-RPC] protocol and what is supported by [http://www.robotframework.org Robot Framework].

==Designing new custom test libraries in .NET==

For this case, you need only follow the .NET remote library interface guidelines when creating your test library for it to be callable from [http://www.robotframework.org Robot Framework].

==Re-using existing .NET libraries for Robot Framework==

For this case, you would need to write a wrapper class library that provides the remote library interface on the front end and makes the actual calls to the desired .NET class library (or web service) on the back end, for it to be callable from [http://www.robotframework.org Robot Framework].

==Using .NET libraries that reference web services==

If loading a .NET library into remote server, and that library references a web service, then in order for the binding to work correctly, you may have to copy the library's or web service client/consumer's app.config (or app.exe.config) data and save it as robotremoteserver.exe.config.

An alternative solution would be to modify the remote server or the remote (class) library to use dynamic binding at runtime rather than the app.config (or appName.exe.config) binding method.

==Documentating your .NET remote library==

You can generate Robot Framework HTML documentation (or maybe even documentation that is logged in test logs during test runs) for your test library by doing the following sequence of steps:

 # Add the desired .NET XML (summary) code comments for classes and class methods to your test class library.
 # Compile the class library with the documentation option to generate an accompanying XML documentation file. If compiling from command line, that would be the "/doc:pathToFile" option.
 # Load the test library and its documentation file with remote server.
 # Run the [http://code.google.com/p/robotframework/wiki/SupportingTools#Library_Documentation_Generator_(libdoc.py) libdoc.py] support tool from Robot Framework to generate the Robot Framework HTML documentation for the test library, as follows:

  `python libdoc.py --name MyLibraryName --argument localhost:8270 Remote`

You can alternatively use IronPython instead of Python here as well.

=Known Issues=

  * Return values are always returned (or type-casted) as a string. ([http://code.google.com/p/sharprobotremoteserver/issues/detail?id=2 issue 2])

  * *get_keyword_names* may return extra .NET library methods that weren't intended to be used by [http://www.robotframework.org Robot Framework] (e.g. internal methods), so just ignore them. Bear in mind that if you don't debug the remote library, you won't notice this issue anyways as [http://www.robotframework.org Robot Framework] doesn't explicitly dump a list of available keywords for the end user to see, except for library documentation generation with libdoc.py. ([http://code.google.com/p/sharprobotremoteserver/issues/detail?id=5 issue 5])

  * keyword output will always be blank except in cases of exceptions being raised. Currently no real definition of what constitutes "output" from a keyword. ([http://code.google.com/p/sharprobotremoteserver/issues/detail?id=3 issue 3])

  * remote library keywords will always return as PASS except for those that have return type as boolean and return false, and in case of exceptions

  * remote library keyword implementations that don't return a basic data type (string, int, bool) or an array of it will not return any value. For those that return an array of basic data type, it will be returned in a delimited string format like _{val1, val2, ...}_ instead of an actual array.

  * Exceptions not caught at the server or library level may be returned as generic [http://www.xml-rpc.net/faq/xmlrpcnetfaq.html#4.2 XML-RPC fault code 0 per XML-RPC.net library]. These uncaught exceptions may or will also cause keyword to fail unexpectedly. ([http://code.google.com/p/sharprobotremoteserver/issues/detail?id=4 issue 4])

  * Remote server currently not designed with "web services" as a remote library in mind, but can be modified to load a "web service" reference as the remote library rather than a local class library assembly DLL. Alternative is to build a wrapper class library that calls/references the web service and then load the wrapper class library with remote server. That way you don't have to modify the remote server code. But with this approach, you may have to create/add a robotremoteserver.exe.config file to specify bindings to the web service, etc. unless you modify the remote server code or implement the wrapper class library to use dynamic binding rather than binding through app.config (or appName.exe.config), etc.

=Tips for Debugging=

  * You can use a REST client (like popular browser extensions) to pass correct [http://www.xmlrpc.com/spec XML-RPC] requests (an HTTP POST with data payload in XML-RPC format) and validate correct XML response from remote library.

  * You can use [http://www.robotframework.org Robot Framework] tests to make the XML-RPC calls and validate correct responses, etc. if you are not good with XML-RPC messaging.

  * For library DLL related issues, you can build other .NET tools (e.g. console app or !WinForms app) to load the same library being used with remote server and test to make sure library works correctly before loading into server at runtime.